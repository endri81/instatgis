---
title: "Leksioni 8"
author: "Endri Raco"
output:
  beamer_presentation:
    includes:
      in_header: mystyle.tex
      fig_width: 7
    fig_height: 6
    number_sections: false
    keep_tex: yes
    theme: Madrid
    toc: yes
    highlight: tango
date: "`r format(Sys.Date(), '%d %B, %Y')`"  
---

```{r setup, include=FALSE}
    library(knitr)
    library(tidyverse)
knitr::opts_chunk$set(
comment=NA,
error=F, 
warning=F,
tidy=TRUE, 
fig.align = 'center',
message=F, 
warning=F,
tidy.opts=list(width.cutoff=60),
fig.width=4, 
fig.height=4, 
fig.path='Figs/')
```

# Të dhënat Raster (vazhdim)

## Analiza e Pikave dhe Vlerësimi i Dendësisë së Kernelit (KDE)

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
import urllib.request

# Shkarkoni të dhënat e anijeve të mbytura historike
url_shipwrecks = 'https://github.com/endri81/instatgis/blob/master/data/gis4/darmc_historical_shipwrecks_500bce_1500ce.geojson?raw=true'
file_name_shipwrecks = 'data/darmc_historical_shipwrecks_500bce_1500ce.geojson'
urllib.request.urlretrieve(url_shipwrecks, file_name_shipwrecks)

# Shkarkoni gjithashtu kufijtë e vendeve
url_boundaries = 'https://github.com/endri81/instatgis/blob/master/data/gis4/natural_earth_world_boundaries_50m_2018.geojson?raw=true'
file_name_boundaries = 'data/natural_earth_world_boundaries_50m_2018.geojson'
urllib.request.urlretrieve(url_boundaries, file_name_boundaries)

```



## Ngarkimi dhe Projekti i Dataset-eve



\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
import geopandas as gpd

# Ngarkoni dataset-in dhe projektoni në 3035 (Lambert, i përshtatshëm për Evropën)
ship_df = gpd.read_file('data/darmc_historical_shipwrecks_500bce_1500ce.geojson').to_crs(3035)
countries_df = gpd.read_file('data/natural_earth_world_boundaries_50m_2018.geojson').to_crs(3035)
```


## Shfaqni një shembull të të dhënave


\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
ship_df.sample(5)
```

## Shfaqni një shembull të të dhënave

![](./Figs/ship.png)


## Vizualizimi i Pikave


\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
import geoplot
import matplotlib.pyplot as plt

# Përkufizoni kanavacën
f, ax = plt.subplots(figsize=(10,7))

# Vizualizoni dy shtresa
countries_df.plot(ax=ax, color='lightgray', edgecolor="none", linewidth=.5)
geoplot.pointplot(ship_df, s=2, color='red', ax=ax, alpha=.1)

# Vendosni kufijtë e hartës
# Krijoni një buffer për të shtuar një margjinë
buff = ship_df.buffer(1)
xlim = ([buff.total_bounds[0], buff.total_bounds[2]])
ylim = ([buff.total_bounds[1], buff.total_bounds[3]])
ax.set_xlim(xlim)
ax.set_ylim(ylim)

# Vendosni titullin e hartës
ax.set_title('Anije të Mbytura (500 p.e.s. - 1500 e.s.)')

# Shfaqni rezultatet
plt.show()
```



## Vizualizimi i Pikave

![](./Figs/anije.png)


## Histogram 2D

  - Një mënyrë më e mirë për të përfaqësuar një densitet hapësinor është një histogram dy-dimensional (hist2d), i        njohur gjithashtu si një grafik rrjeti.

## Histogram 2D

  - Vini re se një nga avantazhet e Python është mundësia e ndryshimit të parametrave të një funksioni përmes një         cikli for (për shembull, numri i shtyllave në një histogram) dhe krahasimi i rezultateve.

## Histogram 2D


\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# riprojektojmë në lon/lat për të pasur koordinata më të interpretueshme
ship_df = ship_df.to_crs(4326)

# le të luajmë me numrin e bins:
for bin_n in [10,20,30,40]:
    print("bin_n",bin_n)
    h = plt.hist2d(ship_df.geometry.x, ship_df.geometry.y, bins=bin_n, density=False)
    plt.colorbar(h[3])
    plt.title('2D histograma e anijeve (bins='+str(bin_n)+")")
    plt.show()
```


## Histogram 2D

  Këto grafikë tregojnë praninë e një zone me densitet jashtëzakonisht të lartë midis Francës, Korsikës dhe Italisë:



## Grafiku KDE

  - Një qasje më shkencore është vlerësimi i densitetit të bërthamës (KDE). 
  
  - **geoplot.kdeplot(...)** mund të vizatojë një KDE duke u nisur nga të dhënat e pikës.
  
## Grafiku KDE

  - Një parametër vendimtar është **bandwidth** (bw), që është pragu i distancës që përdoret për të prodhuar                 sipërfaqen (distancat më të shkurtra rezultojnë në një sipërfaqe më të detajuar):


## Grafiku KDE


\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# transformojmë në lon/lat
ship_df_ll = ship_df.to_crs(4326)

# gjenerojmë KDE me bandwidth të ndryshëm
for bandwidth in [.1, .2, .3, .4]:
    print("bandwidth:",bandwidth)
    # konturet e KDE
    ax = geoplot.kdeplot(ship_df_ll, shade=False, bw=bandwidth, figsize=(12, 12), alpha=.5)
    # shtojmë vijën bregdetare
    countries_df.to_crs(4326).plot(ax=ax, color='lightgray', edgecolor="none", linewidth=.5)
    # shtojmë titull
    plt.title('Dendësia e mbytjeve të anijeve (KDE, bw='+str(bandwidth)+")", fontsize=18)
    # figura
    plt.show()
```



## Grafiku KDE

![](./Figs/kde.png)


## Analiza e të dhënave

  - Këta grafikë KDE tregojnë se dataset-i ka një përqendrim shumë të lartë të pikave në Detin Mesdhe, midis Francës      Jugore, Korsikës dhe Bregut Perëndimor të Italisë. 
  
  - Në të gjitha grafikët, kjo qendër graviteti shfaqet qartë.

## Analiza e të dhënave

  - Në aspektin shkencor, kjo mund të tregojë se kishte shumë më tepër mbytje anijesh aty se gjetkë, ose (më e            mundshme) që të dhënat historike janë më të pasura dhe më të hollësishme për atë zonë.
  

# Algjebra e Hartave

## Algjebra e Hartave

  - Termi "algjebra e hartave" i referohet idesë së aplikimit të operacioneve algjebrike në dataset-e raster.

  - Për shembull, mund të dëshirojmë të zbresim nga njëri- tjetri dy rastera të temperaturës të kapur në kohë të          ndryshme për të vëzhguar ndryshimin e temperaturës:
  
## Algjebra e Hartave  

![](./Figs/map_algebra1.png)

## Algjebra e Hartave

Në praktikë, ky është një operacion aritmetik i aplikuar në çdo qelizë të të dy raster-ve:

![](./Figs/map_algebra2.png)

## Algjebra e hartave në Python

  - Kur aksesojmë raster me **rasterio** ose **gdal**, ne mund të kryejmë çdo lloj llogaritjeje algjebrike lineare mbi     të dhënat duke përdorur **numpy, scipy** dhe shumë paketa të tjera të fuqishme të Python. 
  
  - Statistikat zonale suportohen në librarinë **rasterstats**.


## Algjebra e hartave në Python

  - Kjo është arsyeja kryesore pse Python përdoret gjerësisht në komunitetet e remote sensing, machine learning, dhe      AI. 
  
  
## Ngarkoni të dhënat e temperaturës

  - Si një shembull, le të shkarkojmë dhe vizualizojmë dy datasete raster që përfaqësojnë temperaturën mesatare në        vitin 2000 dhe 2017.

## Ngarkoni të dhënat e temperaturës

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
import urllib.request

# Define new URLs and file names
url_2000 = "https://github.com/endri81/instatgis/blob/master/data/gis4/air_temp_2000-average.tif?raw=true"
url_2017 = "https://github.com/endri81/instatgis/blob/master/data/gis4/air_temp_2017-average.tif?raw=true"
file_name_2000 = 'data/air_temp_2000-average.tif'
file_name_2017 = 'data/air_temp_2017-average.tif'

# Download the files
urllib.request.urlretrieve(url_2000, file_name_2000)
urllib.request.urlretrieve(url_2017, file_name_2017)

```



## Ngarkoni të dhënat e temperaturës

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
temp00 = rasterio.open('data/air_temp_2000-average.tif')
print(temp00.meta)
temp17 = rasterio.open('data/air_temp_2017-average.tif')
print(temp17.meta)
```


## Ngarkoni të dhënat e temperaturës

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
import matplotlib.pyplot as plt
import rasterio
from matplotlib.colors import TwoSlopeNorm
# Vini re diverge_zero: kjo përdoret sepse temperatura në Celsius mund të vizualizohet si diverguese nga zero
plot_raster(temp00, temp00.read(1, masked=True), 'Temperatura mesatare e ajrit (2000)', 'Temperatura mesatare (C)', 
    'RdYlBu_r', diverge_zero=True)
plot_raster(temp17, temp17.read(1, masked=True), 'Temperatura mesatare e ajrit (2017)', 'Temperatura mesatare (C)', 
    'RdYlBu_r', diverge_zero=True)
```


## Ngarkoni të dhënat e temperaturës

![](./Figs/temp200.png)


## Krahasimi i të dhënave raster

  - Vizualisht, nuk është e mundur të dallohen ndryshimet midis të dhënave të vitit 2000 dhe atyre të vitit 2017.

  - Prandaj, do të zbresim dy rasterat e temperaturës, duke përdorur Algjebrën e Hartave. 
  
## Krahasimi i të dhënave raster  
  
  - Në praktikë, Python lejon të bëhet kjo në mënyrë intuitive si **raster_vals2 - raster_vals1**. 
  
  - Këto janë operacione algjebrike lineare të aplikuara në çdo qelizë të matricave.


## Krahasimi i të dhënave raster

  - Pastaj do të ndërtojmë një histogram të vlerave dhe raster-it, duke treguar se temperaturat mesatare janë më të       larta me 0.5 gradë, me disa raste ekstreme pozitive dhe negative që mund të shkaktohen nga gabimet e sensorëve.


## Krahasimi i të dhënave raster

Rezultati do të ruhet në një skedar të ri raster, duke ripërdorur metadatat nga raster-at hyrës.


## Krahasimi i të dhënave raster

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
vals17 = temp17.read(1, masked=True)
vals00 = temp00.read(1, masked=True)
```


## Krahasimi i të dhënave raster

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# zbresim të dy raster-at
vals_diff = vals17 - vals00
print("Statistikat e Diferencës:", vals_diff.min(), round(vals_diff.mean(), 2), vals_diff.max())
print("Diferenca midis mesatareve:", round(vals17.mean()-vals00.mean(), 3))
```


## Krahasimi i të dhënave raster

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# vizatoni histogramin
show_hist(vals_diff, bins=30, lw=0.2, stacked=False, alpha=0.8, label='Nr i qelizave',
    histtype='stepfilled', title="Dallimi në temperaturën mesatare (2000-2017)")
```


## Krahasimi i të dhënave raster

![](./Figs/temphist.png)


## Ndërtojmë rasterin

  - Cmap (Purple - White - Orange) thekson vlerat ekstreme, duke fshehur zonat ku vlerat nuk divergojnë.


## Ndërtojmë rasterin

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
plot_raster(temp17, vals_diff, 'Ndryshimi mesatar i temperaturës së ajrit 2000-2017',
            'Diferenca e temperaturës (C)', 'PuOr_r')
```            
            

## Ndërtojmë rasterin

![](./Figs/tempdif.png)



## Ruani rezultatin në një skedar raster

  - Është e rëndësishme të specifikohen metadatat nga skedarët hyrës, përfshirë CRS, vlerën NODATA dhe transformimin e     koordinatave gjeografike:

## Ruani rezultatin në një skedar raster

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
fout = 'tmp/air_temp_diff_2000_2017.tif'
ds = rasterio.open(fout, 'w',
    driver='GTiff', # formati i skedarit të daljes
    height=vals_diff.shape[0], # madhësia e matricës
    width=vals_diff.shape[1], # madhësia e matricës
    count=1, # numri i bandave
    dtype=vals_diff.dtype, # lloji i të dhënave (p.sh., pikë lundruese)
    crs=temp17.crs, # CRS (p.sh., Lambert, WGS84, UTM, etj.)
    nodata=temp17.nodata, # vlera e përdorur për të përfaqësuar NO DATA
    transform=temp17.transform # transformimi i koordinatave gjeografike
)

ds.write(vals_diff, 1)
ds.close()
print("Raster u ruajt te", fout, '.')
```


## Statistikat zonale

  - Kur dëshirojmë të llogarisim statistikat raster bazuar në një zonë gjeografike, na duhen **statistikat zonale**.

  - Për shembull, mund të dëshirojmë të llogarisim lartësinë mesatare (vlerat) e çdo rrethi (zonave) në Angli.

## Statistikat zonale

  - Si skedar **input**, statistikat zonale kanë nevojë për një raster që përfaqëson vlerat dhe një grup tjetër të        dhënash që përfaqëson zonat për të cilat duam të llogarisim statistikat:


## Statistikat zonale

![](./Figs/zonal1.png)
## Statistikat zonale

  - Në këtë shembull, ne do të përdorim të dhënat evropiane të NOx të përdorura më sipër si vlera dhe zonat               statistikore evropiane (NUTS) si zona.

## Shkarkojmë datat


\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# shkarkoni kufijtë rajonalë të BE-së (niveli NUTS 2, 2021)
nuts2_file = 'data/NUTS_RG_01M_2021_4326_LEVL_2.geojson.gz'
url = 'https://raw.githubusercontent.com/endri81/instatgis/master/data/gis4/NUTS_RG_01M_2021_4326_LEVL_2.geojson.gz'
urllib.request.urlretrieve(url, nuts2_file)

```



## Shkarkojmë datat

Skedari është gzip dhe mund ta hapim direkt me **gzip.open(...)**

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
import geopandas as gpd
import gzip
nuts2_df = gpd.read_file(gzip.open(nuts2_file))
nuts2_df.plot()
```


## Shkarkojmë datat


![](./Figs/gzip.png)



## Kontrollojmë


\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
nuts2_df.sample(5)
```


## Përgatitja e të Dhënave

  - Duke qenë se nuk kemi të dhëna për Guyana Franceze dhe territore të tjera më të vogla, mund t'i heqim ato nga         dataset-i.

## Përgatitja e të Dhënave

Në dataframe pandas, mund të shkruajmë kushte në mënyra të ndryshme:

  - `column.str.contains(string)` kryen një përputhje të pjesshme në një kolonë me format tekst

  - `column.isin(list)` kryen një përputhje të saktë në përmbajtjen e një kolone ndaj një liste

  - `~` do të thotë "jo" (vetëm në kontekstin e pandas)


## Përgatitja e të Dhënave

  - Do projektojmë kufijtë dhe ti ruajmë ato në një GeoPackage. 
  
  - Kini parasysh se GeoJSON lejon vetëm gjeometri në WGS84 (4326). 
  
  - Kur keni një CRS tjetër, duhet të përdorni një GeoPackage.

## Përgatitja e të Dhënave

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# Kjo shprehje do të thotë:
# zgjidhni rreshta ku NUTS_ID nuk përmban 'FRY'
nuts2_df = nuts2_df[~nuts2_df['NUTS_ID'].str.contains("FRY")]

# hiqni rreshtat me kode që korrespondojnë me ishujt për të cilët nuk kemi të dhëna:
nuts2_df = nuts2_df[~nuts2_df['NUTS_ID'].isin(['PT20','PT30','ES70','NO0B'])]

# projektoni në Lambert (i përshtatshëm për Evropën)
nuts2_df = nuts2_df.to_crs(3035)
nuts2_df.info()

# Ky është një rregullim: dataframe gjeo kanë nevojë që FID të jetë i tipit integer
nuts2_df['FID'] = nuts2_df.index
```


## Ruani këtë dataset në një skedar

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
nuts2_clean_file = "tmp/nuts2_boundaries.gpkg"
nuts2_df.to_file(nuts2_clean_file, driver="GPKG")
```

## Vizatoni gjeometrinë

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
nuts2_df.plot(figsize=(10,10))
```



## Vizatoni gjeometrinë

![](./Figs/algebra1.png)


## Statistikat Zonale në Python

  - Statistikat zonale mund të llogariten me funksionin **rasterstats.zonal_stats** 
  
  - Parametri `stats` tregon cilat statistika dëshirojmë të llogariten në çdo zonë.

## Statistikat Zonale në Python

  - Do të llogarisim disa statistika zonale dhe do ta ruajmë rezultatin në një GeoPackage dhe një skedar CSV:


## Statistikat Zonale në Python

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
from rasterstats import zonal_stats

print("Duke llogaritur statistikat zonale midis", nuts2_clean_file, 'dhe data/eu-2016-nox_avg.tif ...')

zon_stats = zonal_stats(nuts2_clean_file, 'data/eu-2016-nox_avg.tif',
                        stats="count min mean max median", geojson_out=True)
print('Përfunduar.')
```

## Statistikat Zonale në Python

  - Rezultati është një listë e fjalorëve që përmban statistikat për çdo rresht të skedarit hyrës të vektorit

  - Këto rezultate mund të konvertohen në një kornizë të të dhënave gjeo kështu:


## Statistikat Zonale në Python

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
import geopandas as gpd
stats_df = gpd.GeoDataFrame.from_features(zon_stats)

# riemërtoni kolonat për të qenë më kuptimplota
stats_df = stats_df.rename(columns={"min": "nox_min",
                                    "max": "nox_max",
                                    "count": "nox_count",
                                    "mean": "nox_mean",
                                    "median": "nox_median"})
stats_df.sample(4)
```


## Statistikat Zonale në Python

![](./Figs/regstat.png)

## Statistikat Zonale në Python


\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# ruajmë rezultatin në një geopackage
stats_df.to_file('tmp/eu_nox_2016_nuts2.gpkg', driver="GPKG")

# për lehtësi ruajmë tabelën e atributeve si CSV
stats_df.drop(columns=['geometry']).to_csv('tmp/eu_nox_2016_nuts2.csv', index=False)
print("results saved.")
```


## Renditja dhe Vizualizimi i Rezultateve

  - Tani, ne mund të eksplorojmë dhe vizualizojmë rezultatet.

  - Funksioni **.rank()** i pandas na lejon të renditim vlerat.
  
## Renditja dhe Vizualizimi i Rezultateve

  - Shpesh është një ide e mirë të ndajmë në qeliza të ndryshme llogaritjet dhe vizualizimet e gjata.

  - Në këtë rast, nëse dëshirojmë të ekzekutojmë vizualizime të ndryshme, nuk kemi nevojë të rikthejmë llogaritjet zonale në qelizën e mëparshme.


## Renditja dhe Vizualizimi i Rezultateve

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
nox_nuts2_df = gpd.read_file('tmp/eu_nox_2016_nuts2.gpkg')
print(nox_nuts2_df.describe())
print(nox_nuts2_df.columns)
```


## Renditja dhe Vizualizimi i Rezultateve

![](./Figs/eunox.png)



## Renditja dhe Vizualizimi i Rezultateve

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# Rendisni rajonet: 1 = vlera më e lartë
nox_nuts2_df['nox_mean_rank'] = nox_nuts2_df['nox_mean'].rank(ascending=False)
nox_nuts2_df['nox_max_rank'] = nox_nuts2_df['nox_max'].rank(ascending=False)
```


## Renditja dhe Vizualizimi i Rezultateve

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# E vërtetë nëse vlera > 40
nox_nuts2_df['nox_max_high'] = nox_nuts2_df['nox_max'] > 40
```


## Renditja dhe Vizualizimi i Rezultateve

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# Shikoni rajonet më të ndotura NUTS, duke përzgjedhur vetëm kolonat përkatëse
sel_df = nox_nuts2_df[['NUTS_ID','NUTS_NAME','nox_mean','nox_max',
                       'nox_mean_rank','nox_max_rank','nox_max_high']]
sel_df.sample(5)

# Rendisni rajonet sipas nox_mean
sel_df.sort_values('nox_mean',ascending=False).head(20)
```


## Renditja dhe Vizualizimi i Rezultateve

![](./Figs/eunox2.png)


## Renditja dhe Vizualizimi i Rezultateve

  - Vini re se si renditja për **nox_max** dhe **nox_mean** mund të ndryshojë:
  
  - Për shembull, Inner London - West ("UKI3") ka nivelin më të lartë të NOx në mesatare, por është vetëm i 23-ti për     sa i përket vlerës maksimale.

## Renditja dhe Vizualizimi i Rezultateve

  - Mund të vizatojmë vlerat e grumbulluara me një choropleth:

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
nox_nuts2_df.plot(column='nox_max', figsize=(12,9), scheme='equalinterval', cmap='OrRd', k=5,
    edgecolor="lightgrey", linewidth=0.4,
    legend=True, legend_kwds={'loc': 'upper right', 'title': 'NOx Maksimale (2016) - NUTS 2'},
    missing_kwds={'color': "lightgrey"})
```


## Renditja dhe Vizualizimi i Rezultateve

![](./Figs/eunox3.png)


## Renditja dhe Vizualizimi i Rezultateve

  - Shpërndarja e NOx është shumë heterogjene hapësinore (dmth., ndryshon shumë në çdo vend).

  - Ne mund të përdorim **groupby** për të gjetur njësinë kryesore të NUTS për çdo vend për sa i përket NOx maksimale:




## Renditja dhe Vizualizimi i Rezultateve

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
nox_nuts2_df['nox_max_country_rank'] = nox_nuts2_df.groupby('CNTR_CODE')['nox_max'].rank(ascending=False)

# për çdo vend, njësitë renditen në mënyrë të brendshme
sel_df = nox_nuts2_df[['NUTS_ID','NUTS_NAME','nox_max','nox_max_country_rank']]
sel_df
```



## Renditja dhe Vizualizimi i Rezultateve

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# Zgjidhni vetëm njësinë kryesore për çdo vend (rank==1) dhe rendisni ato sipas NOx maksimale:
top_df = sel_df[sel_df['nox_max_country_rank']==1]
top_df.sort_values('nox_max', ascending=False)
```


## Renditja dhe Vizualizimi i Rezultateve

![](./Figs/eunox4.png)

