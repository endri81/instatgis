---
title: "Leksioni 9"
author: "Endri Raco"
output:
  beamer_presentation:
    includes:
      in_header: mystyle.tex
      fig_width: 7
    fig_height: 6
    number_sections: false
    keep_tex: yes
    theme: Madrid
    toc: yes
    highlight: tango
date: "`r format(Sys.Date(), '%d %B, %Y')`"  
---

```{r setup, include=FALSE}
    library(knitr)
    library(tidyverse)
knitr::opts_chunk$set(
comment=NA,
error=F, 
warning=F,
tidy=TRUE, 
fig.align = 'center',
message=F, 
warning=F,
tidy.opts=list(width.cutoff=60),
fig.width=4, 
fig.height=4, 
fig.path='Figs/')
```

# Të dhënat Raster (vazhdim)

## Analiza e Pikave dhe Vlerësimi i Dendësisë së Kernelit (KDE)

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
import urllib.request

# Shkarkoni të dhënat e anijeve të mbytura historike
url_shipwrecks = 'https://github.com/endri81/instatgis/blob/master/data/gis4/darmc_historical_shipwrecks_500bce_1500ce.geojson?raw=true'
file_name_shipwrecks = 'data/darmc_historical_shipwrecks_500bce_1500ce.geojson'
urllib.request.urlretrieve(url_shipwrecks, file_name_shipwrecks)

# Shkarkoni gjithashtu kufijtë e vendeve
url_boundaries = 'https://github.com/endri81/instatgis/blob/master/data/gis4/natural_earth_world_boundaries_50m_2018.geojson?raw=true'
file_name_boundaries = 'data/natural_earth_world_boundaries_50m_2018.geojson'
urllib.request.urlretrieve(url_boundaries, file_name_boundaries)

```



## Ngarkimi dhe Projekti i Dataset-eve



\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
import geopandas as gpd

# Ngarkoni dataset-in dhe projektoni në 3035 (Lambert, i përshtatshëm për Evropën)
ship_df = gpd.read_file('data/darmc_historical_shipwrecks_500bce_1500ce.geojson').to_crs(3035)
countries_df = gpd.read_file('data/natural_earth_world_boundaries_50m_2018.geojson').to_crs(3035)
```


## Shfaqni një shembull të të dhënave


\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
ship_df.sample(5)
```

## Shfaqni një shembull të të dhënave

![](./Figs/ship.png)


## Vizualizimi i Pikave


\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
import geoplot
import matplotlib.pyplot as plt

# Përkufizoni kanavacën
f, ax = plt.subplots(figsize=(10,7))

# Vizualizoni dy shtresa
countries_df.plot(ax=ax, color='lightgray', edgecolor="none", linewidth=.5)
geoplot.pointplot(ship_df, s=2, color='red', ax=ax, alpha=.1)

# Vendosni kufijtë e hartës
# Krijoni një buffer për të shtuar një margjinë
buff = ship_df.buffer(1)
xlim = ([buff.total_bounds[0], buff.total_bounds[2]])
ylim = ([buff.total_bounds[1], buff.total_bounds[3]])
ax.set_xlim(xlim)
ax.set_ylim(ylim)

# Vendosni titullin e hartës
ax.set_title('Anije të Mbytura (500 p.e.s. - 1500 e.s.)')

# Shfaqni rezultatet
plt.show()
```



## Vizualizimi i Pikave

![](./Figs/anije.png)


## Histogram 2D

  - Një mënyrë më e mirë për të përfaqësuar një densitet hapësinor është një histogram dy-dimensional (hist2d), i        njohur gjithashtu si një grafik rrjeti.

## Histogram 2D

  - Vini re se një nga avantazhet e Python është mundësia e ndryshimit të parametrave të një funksioni përmes një         cikli for (për shembull, numri i shtyllave në një histogram) dhe krahasimi i rezultateve.

## Histogram 2D


\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# riprojektojmë në lon/lat për të pasur koordinata më të interpretueshme
ship_df = ship_df.to_crs(4326)

# le të luajmë me numrin e bins:
for bin_n in [10,20,30,40]:
    print("bin_n",bin_n)
    h = plt.hist2d(ship_df.geometry.x, ship_df.geometry.y, bins=bin_n, density=False)
    plt.colorbar(h[3])
    plt.title('2D histograma e anijeve (bins='+str(bin_n)+")")
    plt.show()
```


## Histogram 2D

  Këto grafikë tregojnë praninë e një zone me densitet jashtëzakonisht të lartë midis Francës, Korsikës dhe Italisë:



## Grafiku KDE

  - Një qasje më shkencore është vlerësimi i densitetit të bërthamës (KDE). 
  
  - **geoplot.kdeplot(...)** mund të vizatojë një KDE duke u nisur nga të dhënat e pikës.
  
## Grafiku KDE

  - Një parametër vendimtar është **bandwidth** (bw), që është pragu i distancës që përdoret për të prodhuar                 sipërfaqen (distancat më të shkurtra rezultojnë në një sipërfaqe më të detajuar):


## Grafiku KDE


\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# transformojmë në lon/lat
ship_df_ll = ship_df.to_crs(4326)

# gjenerojmë KDE me bandwidth të ndryshëm
for bandwidth in [.1, .2, .3, .4]:
    print("bandwidth:",bandwidth)
    # konturet e KDE
    ax = geoplot.kdeplot(ship_df_ll, shade=False, bw=bandwidth, figsize=(12, 12), alpha=.5)
    # shtojmë vijën bregdetare
    countries_df.to_crs(4326).plot(ax=ax, color='lightgray', edgecolor="none", linewidth=.5)
    # shtojmë titull
    plt.title('Dendësia e mbytjeve të anijeve (KDE, bw='+str(bandwidth)+")", fontsize=18)
    # figura
    plt.show()
```



## Grafiku KDE

![](./Figs/kde.png)


## Analiza e të dhënave

  - Këta grafikë KDE tregojnë se dataset-i ka një përqendrim shumë të lartë të pikave në Detin Mesdhe, midis Francës      Jugore, Korsikës dhe Bregut Perëndimor të Italisë. 
  
  - Në të gjitha grafikët, kjo qendër graviteti shfaqet qartë.

## Analiza e të dhënave

  - Në aspektin shkencor, kjo mund të tregojë se kishte shumë më tepër mbytje anijesh aty se gjetkë, ose (më e            mundshme) që të dhënat historike janë më të pasura dhe më të hollësishme për atë zonë.
  

# Algjebra e Hartave

## Algjebra e Hartave

  - Termi "algjebra e hartave" i referohet idesë së aplikimit të operacioneve algjebrike në dataset-e raster.

  - Për shembull, mund të dëshirojmë të zbresim nga njëri- tjetri dy rastera të temperaturës të kapur në kohë të          ndryshme për të vëzhguar ndryshimin e temperaturës:
  
## Algjebra e Hartave  

![](./Figs/map_algebra1.png)

## Algjebra e Hartave

Në praktikë, ky është një operacion aritmetik i aplikuar në çdo qelizë të të dy raster-ve:

![](./Figs/map_algebra2.png)

## Algjebra e hartave në Python

  - Kur aksesojmë raster me **rasterio** ose **gdal**, ne mund të kryejmë çdo lloj llogaritjeje algjebrike lineare mbi     të dhënat duke përdorur **numpy, scipy** dhe shumë paketa të tjera të fuqishme të Python. 
  
  - Statistikat zonale suportohen në librarinë **rasterstats**.


## Algjebra e hartave në Python

  - Kjo është arsyeja kryesore pse Python përdoret gjerësisht në komunitetet e remote sensing, machine learning, dhe      AI. 
  
  
## Ngarkoni të dhënat e temperaturës

  - Si një shembull, le të shkarkojmë dhe vizualizojmë dy datasete raster që përfaqësojnë temperaturën mesatare në        vitin 2000 dhe 2017.

## Ngarkoni të dhënat e temperaturës

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
import urllib.request

# Define new URLs and file names
url_2000 = "https://github.com/endri81/instatgis/blob/master/data/gis4/air_temp_2000-average.tif?raw=true"
url_2017 = "https://github.com/endri81/instatgis/blob/master/data/gis4/air_temp_2017-average.tif?raw=true"
file_name_2000 = 'data/air_temp_2000-average.tif'
file_name_2017 = 'data/air_temp_2017-average.tif'

# Download the files
urllib.request.urlretrieve(url_2000, file_name_2000)
urllib.request.urlretrieve(url_2017, file_name_2017)

```



## Ngarkoni të dhënat e temperaturës

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
temp00 = rasterio.open('data/air_temp_2000-average.tif')
print(temp00.meta)
temp17 = rasterio.open('data/air_temp_2017-average.tif')
print(temp17.meta)
```


## Ngarkoni të dhënat e temperaturës

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
import matplotlib.pyplot as plt
import rasterio
from matplotlib.colors import TwoSlopeNorm
# Vini re diverge_zero: kjo përdoret sepse temperatura në Celsius mund të vizualizohet si diverguese nga zero
plot_raster(temp00, temp00.read(1, masked=True), 'Temperatura mesatare e ajrit (2000)', 'Temperatura mesatare (C)', 
    'RdYlBu_r', diverge_zero=True)
plot_raster(temp17, temp17.read(1, masked=True), 'Temperatura mesatare e ajrit (2017)', 'Temperatura mesatare (C)', 
    'RdYlBu_r', diverge_zero=True)
```


## Ngarkoni të dhënat e temperaturës

![](./Figs/temp200.png)


## Krahasimi i të dhënave raster

  - Vizualisht, nuk është e mundur të dallohen ndryshimet midis të dhënave të vitit 2000 dhe atyre të vitit 2017.

  - Prandaj, do të zbresim dy rasterat e temperaturës, duke përdorur Algjebrën e Hartave. 
  
## Krahasimi i të dhënave raster  
  
  - Në praktikë, Python lejon të bëhet kjo në mënyrë intuitive si **raster_vals2 - raster_vals1**. 
  
  - Këto janë operacione algjebrike lineare të aplikuara në çdo qelizë të matricave.


## Krahasimi i të dhënave raster

  - Pastaj do të ndërtojmë një histogram të vlerave dhe raster-it, duke treguar se temperaturat mesatare janë më të       larta me 0.5 gradë, me disa raste ekstreme pozitive dhe negative që mund të shkaktohen nga gabimet e sensorëve.


## Krahasimi i të dhënave raster

Rezultati do të ruhet në një skedar të ri raster, duke ripërdorur metadatat nga raster-at hyrës.


## Krahasimi i të dhënave raster

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
vals17 = temp17.read(1, masked=True)
vals00 = temp00.read(1, masked=True)
```


## Krahasimi i të dhënave raster

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# zbresim të dy raster-at
vals_diff = vals17 - vals00
print("Statistikat e Diferencës:", vals_diff.min(), round(vals_diff.mean(), 2), vals_diff.max())
print("Diferenca midis mesatareve:", round(vals17.mean()-vals00.mean(), 3))
```


## Krahasimi i të dhënave raster

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# vizatoni histogramin
show_hist(vals_diff, bins=30, lw=0.2, stacked=False, alpha=0.8, label='Nr i qelizave',
    histtype='stepfilled', title="Dallimi në temperaturën mesatare (2000-2017)")
```


## Krahasimi i të dhënave raster

![](./Figs/temphist.png)


## Ndërtojmë rasterin

  - Cmap (Purple - White - Orange) thekson vlerat ekstreme, duke fshehur zonat ku vlerat nuk divergojnë.


## Ndërtojmë rasterin

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
plot_raster(temp17, vals_diff, 'Ndryshimi mesatar i temperaturës së ajrit 2000-2017',
            'Diferenca e temperaturës (C)', 'PuOr_r')
```            
            

## Ndërtojmë rasterin

![](./Figs/tempdif.png)



## Ruani rezultatin në një skedar raster

  - Është e rëndësishme të specifikohen metadatat nga skedarët hyrës, përfshirë CRS, vlerën NODATA dhe transformimin e     koordinatave gjeografike:

## Ruani rezultatin në një skedar raster

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
fout = 'tmp/air_temp_diff_2000_2017.tif'
ds = rasterio.open(fout, 'w',
    driver='GTiff', # formati i skedarit të daljes
    height=vals_diff.shape[0], # madhësia e matricës
    width=vals_diff.shape[1], # madhësia e matricës
    count=1, # numri i bandave
    dtype=vals_diff.dtype, # lloji i të dhënave (p.sh., pikë lundruese)
    crs=temp17.crs, # CRS (p.sh., Lambert, WGS84, UTM, etj.)
    nodata=temp17.nodata, # vlera e përdorur për të përfaqësuar NO DATA
    transform=temp17.transform # transformimi i koordinatave gjeografike
)

ds.write(vals_diff, 1)
ds.close()
print("Raster u ruajt te", fout, '.')
```


## Statistikat zonale

  - Kur dëshirojmë të llogarisim statistikat raster bazuar në një zonë gjeografike, na duhen **statistikat zonale**.

  - Për shembull, mund të dëshirojmë të llogarisim lartësinë mesatare (vlerat) e çdo rrethi (zonave) në Angli.

## Statistikat zonale

  - Si skedar **input**, statistikat zonale kanë nevojë për një raster që përfaqëson vlerat dhe një grup tjetër të        dhënash që përfaqëson zonat për të cilat duam të llogarisim statistikat:


## Statistikat zonale

![](./Figs/zonal1.png)
## Statistikat zonale

  - Në këtë shembull, ne do të përdorim të dhënat evropiane të NOx të përdorura më sipër si vlera dhe zonat               statistikore evropiane (NUTS) si zona.

## Shkarkojmë datat


\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# shkarkoni kufijtë rajonalë të BE-së (niveli NUTS 2, 2021)
nuts2_file = 'data/NUTS_RG_01M_2021_4326_LEVL_2.geojson.gz'
url = 'https://raw.githubusercontent.com/endri81/instatgis/master/data/gis4/NUTS_RG_01M_2021_4326_LEVL_2.geojson.gz'
urllib.request.urlretrieve(url, nuts2_file)

```



## Shkarkojmë datat

Skedari është gzip dhe mund ta hapim direkt me **gzip.open(...)**

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
import geopandas as gpd
import gzip
nuts2_df = gpd.read_file(gzip.open(nuts2_file))
nuts2_df.plot()
```


## Shkarkojmë datat


![](./Figs/gzip.png)



## Kontrollojmë


\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
nuts2_df.sample(5)
```


## Përgatitja e të Dhënave

  - Duke qenë se nuk kemi të dhëna për Guyana Franceze dhe territore të tjera më të vogla, mund t'i heqim ato nga         dataset-i.

## Përgatitja e të Dhënave

Në dataframe pandas, mund të shkruajmë kushte në mënyra të ndryshme:

  - `column.str.contains(string)` kryen një përputhje të pjesshme në një kolonë me format tekst

  - `column.isin(list)` kryen një përputhje të saktë në përmbajtjen e një kolone ndaj një liste

  - `~` do të thotë "jo" (vetëm në kontekstin e pandas)


## Përgatitja e të Dhënave

  - Do projektojmë kufijtë dhe ti ruajmë ato në një GeoPackage. 
  
  - Kini parasysh se GeoJSON lejon vetëm gjeometri në WGS84 (4326). 
  
  - Kur keni një CRS tjetër, duhet të përdorni një GeoPackage.

## Përgatitja e të Dhënave

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# Kjo shprehje do të thotë:
# zgjidhni rreshta ku NUTS_ID nuk përmban 'FRY'
nuts2_df = nuts2_df[~nuts2_df['NUTS_ID'].str.contains("FRY")]

# hiqni rreshtat me kode që korrespondojnë me ishujt për të cilët nuk kemi të dhëna:
nuts2_df = nuts2_df[~nuts2_df['NUTS_ID'].isin(['PT20','PT30','ES70','NO0B'])]

# projektoni në Lambert (i përshtatshëm për Evropën)
nuts2_df = nuts2_df.to_crs(3035)
nuts2_df.info()

# Ky është një rregullim: dataframe gjeo kanë nevojë që FID të jetë i tipit integer
nuts2_df['FID'] = nuts2_df.index
```


## Ruani këtë dataset në një skedar

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
nuts2_clean_file = "tmp/nuts2_boundaries.gpkg"
nuts2_df.to_file(nuts2_clean_file, driver="GPKG")
```

## Vizatoni gjeometrinë

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
nuts2_df.plot(figsize=(10,10))
```



## Vizatoni gjeometrinë

![](./Figs/algebra1.png)


## Statistikat Zonale në Python

  - Statistikat zonale mund të llogariten me funksionin **rasterstats.zonal_stats** 
  
  - Parametri `stats` tregon cilat statistika dëshirojmë të llogariten në çdo zonë.

## Statistikat Zonale në Python

  - Do të llogarisim disa statistika zonale dhe do ta ruajmë rezultatin në një GeoPackage dhe një skedar CSV:


## Statistikat Zonale në Python

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
from rasterstats import zonal_stats

print("Duke llogaritur statistikat zonale midis", nuts2_clean_file, 'dhe data/eu-2016-nox_avg.tif ...')

zon_stats = zonal_stats(nuts2_clean_file, 'data/eu-2016-nox_avg.tif',
                        stats="count min mean max median", geojson_out=True)
print('Përfunduar.')
```

## Statistikat Zonale në Python

  - Rezultati është një listë e fjalorëve që përmban statistikat për çdo rresht të skedarit hyrës të vektorit

  - Këto rezultate mund të konvertohen në një kornizë të të dhënave gjeo kështu:


## Statistikat Zonale në Python

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
import geopandas as gpd
stats_df = gpd.GeoDataFrame.from_features(zon_stats)

# riemërtoni kolonat për të qenë më kuptimplota
stats_df = stats_df.rename(columns={"min": "nox_min",
                                    "max": "nox_max",
                                    "count": "nox_count",
                                    "mean": "nox_mean",
                                    "median": "nox_median"})
stats_df.sample(4)
```


## Statistikat Zonale në Python

![](./Figs/regstat.png)

## Statistikat Zonale në Python


\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# ruajmë rezultatin në një geopackage
stats_df.to_file('tmp/eu_nox_2016_nuts2.gpkg', driver="GPKG")

# për lehtësi ruajmë tabelën e atributeve si CSV
stats_df.drop(columns=['geometry']).to_csv('tmp/eu_nox_2016_nuts2.csv', index=False)
print("results saved.")
```


## Renditja dhe Vizualizimi i Rezultateve

  - Tani, ne mund të eksplorojmë dhe vizualizojmë rezultatet.

  - Funksioni **.rank()** i pandas na lejon të renditim vlerat.
  
## Renditja dhe Vizualizimi i Rezultateve

  - Shpesh është një ide e mirë të ndajmë në qeliza të ndryshme llogaritjet dhe vizualizimet e gjata.

  - Në këtë rast, nëse dëshirojmë të ekzekutojmë vizualizime të ndryshme, nuk kemi nevojë të rikthejmë llogaritjet zonale në qelizën e mëparshme.


## Renditja dhe Vizualizimi i Rezultateve

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
nox_nuts2_df = gpd.read_file('tmp/eu_nox_2016_nuts2.gpkg')
print(nox_nuts2_df.describe())
print(nox_nuts2_df.columns)
```


## Renditja dhe Vizualizimi i Rezultateve

![](./Figs/eunox.png)



## Renditja dhe Vizualizimi i Rezultateve

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# Rendisni rajonet: 1 = vlera më e lartë
nox_nuts2_df['nox_mean_rank'] = nox_nuts2_df['nox_mean'].rank(ascending=False)
nox_nuts2_df['nox_max_rank'] = nox_nuts2_df['nox_max'].rank(ascending=False)
```


## Renditja dhe Vizualizimi i Rezultateve

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# E vërtetë nëse vlera > 40
nox_nuts2_df['nox_max_high'] = nox_nuts2_df['nox_max'] > 40
```


## Renditja dhe Vizualizimi i Rezultateve

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# Shikoni rajonet më të ndotura NUTS, duke përzgjedhur vetëm kolonat përkatëse
sel_df = nox_nuts2_df[['NUTS_ID','NUTS_NAME','nox_mean','nox_max',
                       'nox_mean_rank','nox_max_rank','nox_max_high']]
sel_df.sample(5)

# Rendisni rajonet sipas nox_mean
sel_df.sort_values('nox_mean',ascending=False).head(20)
```


## Renditja dhe Vizualizimi i Rezultateve

![](./Figs/eunox2.png)


## Renditja dhe Vizualizimi i Rezultateve

  - Vini re se si renditja për **nox_max** dhe **nox_mean** mund të ndryshojë:
  
  - Për shembull, Inner London - West ("UKI3") ka nivelin më të lartë të NOx në mesatare, por është vetëm i 23-ti për     sa i përket vlerës maksimale.

## Renditja dhe Vizualizimi i Rezultateve

  - Mund të vizatojmë vlerat e grumbulluara me një choropleth:

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
nox_nuts2_df.plot(column='nox_max', figsize=(12,9), scheme='equalinterval', cmap='OrRd', k=5,
    edgecolor="lightgrey", linewidth=0.4,
    legend=True, legend_kwds={'loc': 'upper right', 'title': 'NOx Maksimale (2016) - NUTS 2'},
    missing_kwds={'color': "lightgrey"})
```


## Renditja dhe Vizualizimi i Rezultateve

![](./Figs/eunox3.png)


## Renditja dhe Vizualizimi i Rezultateve

  - Shpërndarja e NOx është shumë heterogjene hapësinore (dmth., ndryshon shumë në çdo vend).

  - Ne mund të përdorim **groupby** për të gjetur njësinë kryesore të NUTS për çdo vend për sa i përket NOx maksimale:




## Renditja dhe Vizualizimi i Rezultateve

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
nox_nuts2_df['nox_max_country_rank'] = nox_nuts2_df.groupby('CNTR_CODE')['nox_max'].rank(ascending=False)

# për çdo vend, njësitë renditen në mënyrë të brendshme
sel_df = nox_nuts2_df[['NUTS_ID','NUTS_NAME','nox_max','nox_max_country_rank']]
sel_df
```



## Renditja dhe Vizualizimi i Rezultateve

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# Zgjidhni vetëm njësinë kryesore për çdo vend (rank==1) dhe rendisni ato sipas NOx maksimale:
top_df = sel_df[sel_df['nox_max_country_rank']==1]
top_df.sort_values('nox_max', ascending=False)
```


## Renditja dhe Vizualizimi i Rezultateve

![](./Figs/eunox4.png)


# Praktikë


## Detyra 1


  - Do ngarkojmë dataset që përmban raster me të dhëna globale të reshjeve nga viti 1950 deri në vitin 2017 në            milimetra nga url [https://raw.githubusercontent.com/endri81/instatgis/master/data/global_precipitation_1950_2017/     rasters/](https://raw.githubusercontent.com/endri81/instatgis/master/data/global_precipitation_1950_2017/rasters/)

  - Duke përdorur cikle for, merrni raster-in e reshjeve çdo 5 vjet nga viti 1980 deri në vitin 2015.

  - Për çdo raster, gjeneroni një grafik duke përdorur funksionin **plot_raster** (funksioni në 2 slidet e tjera) dhe         printoni vlerat minimale, mesatare dhe maksimale.


## Funksioni plot_raster

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}
# Duke qenë se funksionaliteti i vizualizimit të rasterio është mjaft i komplikuar,
# ne krijojmë një funksion për të vizualizuar një raster më lehtë.
# Vini re vlerat e paracaktuara (Blues, 10, 10).
# Sa i përket kompleksitetit, kjo është një funksion realist i përdorur në shkencën e të dhënave,
# me "hack"-e për t'i bërë gjërat të funksionojnë për shkak të kufizimeve të paketës.

def plot_raster(rast, val_matrix, plot_title, value_label, cmap='Blues', width=10, height=10, diverge_zero=False):
    """Vizualizon një rasterio raster me cilësime të arsyeshme dhe me legjendë.
        @ rast: skedari rasterio (përdoret për të lexuar koordinatat gjeografike)
        @ val_matrix: vlerat e nxjerra (përdoret për të lexuar vlerat e rasterit)
        @ plot_title: titulli i figurës së plotë
        @ value_label: sasia që shfaqet
        @ diverge_zero: e vërtetë nëse përdorni një cmap divergjent për të përqendruar hartën e ngjyrave në zero
    """
    fig, ax = plt.subplots(figsize=(10,10))
    # image_hidden është një "hack" për të treguar legjendën
    if diverge_zero:
        image_hidden = ax.imshow(val_matrix, cmap=cmap, norm=TwoSlopeNorm(0))
    else:
        image_hidden = ax.imshow(val_matrix, cmap=cmap)

    ax.clear()

```    
    
## Funksioni plot_raster (vazhdim)

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}    
    # vizualizoni raster: rast.transform lejon sistemin të tregojë koordinatat gjeografike
    if diverge_zero:
        rast_plot = rasterio.plot.show(val_matrix, cmap=cmap, ax=ax, transform=rast.transform, norm=TwoSlopeNorm(0))
    else: 
        rast_plot = rasterio.plot.show(val_matrix, cmap=cmap, ax=ax, transform=rast.transform)
    
    # vendosni titullin e grafikut
    ax.set_title(plot_title, fontsize=14)
    
    # shfaqni legjendën me etiketën
    # "hack" për të rregulluar lartësinë
    im_ratio = val_matrix.shape[0]/val_matrix.shape[1] 
    #plt.colorbar(im,fraction=0.046*im_ratio, pad=0.04)
    cbar = fig.colorbar(image_hidden, ax=ax, fraction=0.046*im_ratio, pad=0.04)
    cbar.ax.set_ylabel(value_label, rotation=270)
    cbar.ax.get_yaxis().labelpad = 15
    #ax.set_axis_off() # aktivizoni/çaktivizoni akset
    plt.show()
```


## Zgjidhje

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}  
import urllib.request

# shkarkoni skedarët. Asc qëndron për Ascii, një format i thjeshtë raster.
years = range(1980, 2016, 5)
base_url = 'https://raw.githubusercontent.com/endri81/instatgis/master/data/global_precipitation_1950_2017/rasters/'

for year in years:
    rast_url = base_url + 'precip_{}-total.asc'.format(year)
    local_file_name = 'data/global_precip_raster-{}.asc'.format(year)
    print(local_file_name)
    urllib.request.urlretrieve(rast_url, local_file_name)
    del rast_url, local_file_name
```


## Zgjidhje

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE}  
# Për thjeshtësi, ne po i mbajmë të gjithë rastet në një sistem referimi gjeografik.
# Në një studim shkencor, do të na duhej t'i projektonim ato për vizualizim.

# ndertojmë rasterat e reshjeve:
for year in years:
    # gjenerojme emer lokal
    local_file_name = 'data/global_precip_raster-{}.asc'.format(year)
    # open raster
    precip_rast = rasterio.open(local_file_name, mask=True)
    # plot
    plot_raster(precip_rast, precip_rast.read(1, masked=True), 
        'Rreshjet totale vjetore (mm) '+str(year), 'mm', 
        cmap='GnBu', width=14, height=14)
```


## Zgjidhje

![](./Figs/reshtotvjet.png)


## Ushtrimi 2

  - Duke përdorur veprimin e zbritjes nga algjebra e hartës, llogarisni dhe vizatoni diferencën e rasterit midis          viteve 1980, 1990, 2000 dhe 2010 (3 çifte). 
  
  - Përdorni një cikël **for**. 
  
  - Ripërdorni funksionin **plot_raster**
  
  
## Ndihmë

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE} 
years = [1980,1990,2000,2010]
# loop sipas viteve
for i in range(len(years)-1):
    year1 = years[i]
    year2 = years[i+1]
    print(year1,year2)
    # fusnin kodin ketu
```


## Zgjidhje

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE} 

years = [1980,1990,2000,2010]
# loop sipas viteve
for i in range(len(years)-1):
    year1 = years[i]
    year2 = years[i+1]
    print("Krahaso:", year1, year2)
    # Ngarkojme dy rastera per krahasim
    rast1 = rasterio.open('data/global_precip_raster-{}.asc'.format(year1), mask=True)
    rast2 = rasterio.open('data/global_precip_raster-{}.asc'.format(year2), mask=True)
    vals1 = rast1.read(1, masked=True)
    vals2 = rast2.read(1, masked=True)
    # Llogarisim diferencen
    vals_diff = vals2-vals1
    print("Statistikat e diferences:", vals_diff.min(), round(vals_diff.mean(),2), vals_diff.max())
    # Vizatoni diferencen
    plot_raster(rast1, vals_diff, 'Total precipitation change between {} and {}'.format(year1,year2), 
            'Rreshje vjetore (mm)', 'PuOr', width=10, height=10, diverge_zero=True)
    
```



## Zgjidhje

![](./Figs/krahasim.png)

## Ushtrimi 3

  - Sa është sasia e reshjeve totale në çdo vend në vitin 2015?
  
  - Duke përdorur kufijtë e botës, përdorni statistikat zonale për t'iu përgjigjur kësaj pyetjeje.

  - Për çdo vend, llogarisni reshjet minimale, maksimale, mesatare, mediane dhe totale.

  - Ruani rezultatet në një tabelë CSV me një rresht për çdo vend dhe një kolonë për çdo statistikë përshkruese.

## Ushtrimi 3 (vazhdim)

  - Vini re se të dhënat e reshjeve janë shumë dhe rezultatet mund të paraqesin gabime të mëdha për vendet e vogla.

  - Përsëriteni analizën për vitin 1980: Duhet të bëni ndryshime minimale në kod.

## Ndihmë

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE} 
year = 2015
output_file = 'tmp/precipitation_country_stats_' + str(year) + '.csv'
print(output_file)

# futni kodin tuaj këtu
```


## Zgjidhje

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE} 
# shkarkojmë hartën e botës
# Shkarkoni gjithashtu kufijtë e vendeve
url_boundaries = 'https://github.com/endri81/instatgis/blob/master/data/gis4/natural_earth_world_boundaries_50m_2018.geojson?raw=true'
file_name_boundaries = 'data/natural_earth_world_boundaries_50m_2018.geojson'
urllib.request.urlretrieve(url_boundaries, file_name_boundaries)
```

## Zgjidhje

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE} 
# Ngarkojmë kufijtë
countries_df = gpd.read_file('data/natural_earth_world_boundaries_50m_2018.geojson')
# heqim vendet e panjohura
countries_df = countries_df[countries_df.iso_a3 != '-99']
print(len(countries_df))
countries_df.plot()

```


## Zgjidhje

![](./Figs/bota.png)


## Zgjidhje

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE} 
from rasterstats import zonal_stats, gen_zonal_stats

for year in [1980, 2015]:
    print("\nDuke llogaritur statistikat zonale midis kufijve të vendeve të botës dhe reshjeve në {}...".format(year))
    # ngarkoni rasterin e reshjeve
    rast_file = 'data/global_precip_raster-{}.asc'.format(year)
    # gjeneroni rrugën e skedarit të daljes
    output_file = 'tmp/precipitation_country_stats_{}.csv'.format(year)
    # llogarit statistikat zonale
    # zgjidhni vetëm kolonat përkatëse nga countries_df
    zon_stats = zonal_stats(countries_df[['iso_a3','name','geometry']], rast_file, 
                            stats="count min median mean max sum", geojson_out=True)
    # gjeneroni një kornizë të dhënash nga rezultatet e zonal_stats (listë fjalorësh)
    stats_gdf = gpd.GeoDataFrame.from_features(zon_stats)
    # konverto nga geodataframe në dataframe, pasi nuk kemi nevojë për gjeometrinë
    stats_df = pd.DataFrame(stats_gdf.drop(columns='geometry'))    
    # hiqni vendet për të cilat nuk kemi vëzhgime
    stats_df = stats_df[stats_df['count'] > 0]
    stats_df = stats_df.sort_values('sum')
    # printoni statistikat
    print(stats_df.describe())
    # ruani rezultatet në skedar
    stats_df.to_csv(output_file, index=False)
    print("Rezultatet janë te", output_file)


```



## Zgjidhje

  
![](./Figs/rezultate.png)

## Ushtrimi 4

  - Duke përdorur **.rank()**, gjeneroni renditje për vendet për sa i përket reshjeve të tyre (renditja 1                korrespondon me vendin më të lagësht).

  - Tregoni 10 vendet më të thata dhe më të lagështa në botë në vitin 1980 dhe 2015. 
  
  - A mund të vini re shumë ndryshime?


## Ndihmë

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE} 
years = [1980, 2015]
for year in years:
    input_stats_file = 'tmp/precipitation_country_stats_' + str(year) + '.csv'
    print(input_stats_file)
    # ngarkoni skedarin dhe gjeneroni renditje
```    


## Zgjidhje

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE} 
# përcaktojmë "wet rank" bazuar në precipitimin mesatar.
years = [1980,2015]

# bashkojmë statistikat në vite
wet_rank_df = countries_df[['iso_a3','name']]

for year in years:
    input_stats_file = 'tmp/precipitation_country_stats_'+str(year)+'.csv'
    print("ranking",input_stats_file)
    # ngarkojme skedarin
    stats_df = pd.read_csv(input_stats_file)
    # gjenerojme renditje
    rank_field = 'wet_rank_'+str(year)
    stats_df[rank_field] = stats_df['mean'].rank(ascending=False)
    # bashkojme rankimin me rezultatet finale
    wet_rank_df = wet_rank_df.merge(stats_df[['iso_a3',rank_field]], 
                                    on='iso_a3')

# sort dhe ruaj rezultate
wet_rank_df['wet_rank_change'] = wet_rank_df['wet_rank_1980']-wet_rank_df['wet_rank_2015']
wet_rank_df = wet_rank_df.sort_values('wet_rank_2015')
wet_rank_df.to_csv('tmp/precipitation_country_stats.csv', index=False)
# vendet më të lagështa 2015
wet_rank_df.head(10)
```




## Zgjidhje

  
![](./Figs/usht4.png)


## Zgjidhje

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE} 
# vendet më të thata 2015
wet_rank_df.tail(10)
```




## Zgjidhje

  
![](./Figs/usht41.png)



## Zgjidhje

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE} 
# vendet me ndryshime ekstreme në klasifikim
wet_rank_df['wet_rank_change'].hist()
```




## Zgjidhje

  
![](./Figs/usht42.png)



## Zgjidhje

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE} 
# vendet me ndryshime ekstreme 
wet_rank_df = wet_rank_df.sort_values('wet_rank_change', ascending=False)
# Kontrollojmë diapazonin
extreme_change_df = wet_rank_df[~wet_rank_df.wet_rank_change.between(-20, 20)]
extreme_change_df
```




## Zgjidhje

  
![](./Figs/usht43.png)




    
## Ushtrimi 5

  - Duke përdorur **urllib.request.urlretrieve**, shkarkoni këtë dataset që përmban aeroportet globale.
  
  - Ngarkojeni në një dataframe gjeo me geopandas dhe printoni sa rreshta përmban.

  - Zgjidhni disa atribute prej saj, duke përfshirë emrin e aeroportit, kodin IATA të aeroportit, kodin e vendit, lartësinë dhe tipin.


## Ndihmë

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE} 
import urllib.request

# URL e azhurnuar për skedarin e aeroportit
airports_url = 'https://raw.githubusercontent.com/endri81/instatgis/master/data/gis4/airports_2020.geojson'

# Skedari lokal ku do të ruhet të dhënat
local_file_name = 'data/airports_2020.geojson'
print(local_file_name)

# Shkarkoni skedarin nga URL-ja
urllib.request.urlretrieve(airports_url, local_file_name)

# futni kodin tuaj këtu
```



## Zgjidhje

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE} 
airports_all_df = gpd.read_file('data/airports_2020.geojson')
print('n airports =',len(airports_all_df))
print(airports_all_df.columns)
airports_all_df.sample(5)
```




## Zgjidhje

  
![](./Figs/usht5.png)


## Zgjidhje

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE} 
airports_df = airports_all_df[['id','iata_code','name','type','iso_countr','elevation_','geometry']]
# rename elevation to show it is in feet
airports_df = airports_df.rename(columns={"elevation_": "elevation_ft"})
# show sample
airports_df.sample(5)
```




## Zgjidhje

  
![](./Figs/usht51.png)


## Ushtrimi 6

  - Analizoni densitetin e aeroporteve në botë.

  - Së pari, duke përdorur një histogram 2D me numër të ndryshëm të koshave (nga 20 në 100).

  - Bëni analizën për të gjitha aeroportet dhe vetëm për aeroportet e mëdha (type=='large_airport').


## Zgjidhje

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE} 
# ndryshojmë numrin e bin:
for bin_n in range(40,201,40):
    print("bin_n",bin_n)
    
    # ndryshojmë tipin
    for atype in ['all','large_airport']:
        df = airports_df
        if atype != 'all':
            df = airports_df[airports_df['type'] == atype]
        assert len(df) > 0
        # aeroportet e kërkuara janë në df
        h = plt.hist2d(df.geometry.x, df.geometry.y, bins=bin_n, density=False)
        plt.colorbar(h[3])
        plt.title("2D histograma e aeroporteve (type={}, bins={})".format(atype, bin_n))
        plt.show()
```




## Zgjidhje

  
![](./Figs/usht6.png)


## Ushtrimi 7

  - Gjeneroni KDE për aeroportet për Britaninë dhe SHBA-në duke ndryshuar gjerësinë e brezit në tre vlera të ndryshme     që kapin shpërndarjen e aeroporteve në një mënyrë të përshtatshme.

  - Ku janë zonat më të dendura në botë? Ndani analizën midis të gjitha aeroporteve dhe vetëm aeroporteve të mëdha,    duke minimizuar përsëritjen e kodit.
  
  
## Zgjidhje

\AddToHookNext{env/Highlighting/begin}{\tiny}   


```{python, eval = FALSE} 
import geoplot
import matplotlib.pyplot as plt

# Për secilin vend, 'US' dhe 'GB'
for country in ['US', 'GB']:
    # zgjidh aeroportet në adf
    adf = airports_df[airports_df['iso_countr'] == country]
    cdf = countries_df[countries_df['iso_a2'] == country]
    
    # nëse vendi është 'GB', largoni një aeroport RAF në Qipro
    if country == 'GB':
        adf = adf[adf['iata_code'] != 'AKT']
    
    # sigurohuni që të dhënat e vendit dhe aeroportit të mos jenë bosh
    assert len(cdf) > 0
    assert len(adf) > 0

    # ndryshoni bandwidth
    for bandwidth in [.01, .05, .1]:
        title = 'KDE për aeroportet (vendi={}, bandwidth={})'.format(country, bandwidth)
        ax = geoplot.kdeplot(adf, shade=False, bw=bandwidth, figsize=(12, 12), alpha=.5)
        
        # shtoni vijën bregdetare
        cdf.plot(ax=ax, color='lightgray', edgecolor="none", linewidth=.5)
        
        # shtoni titullin
        plt.title(title, fontsize=18)
        
        # shfaqni figurën
        plt.show()
```




## Zgjidhje

  
![](./Figs/usht7.png)  
